// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import "@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol";
import "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol";
import "./interface/IBRT.sol";
import "./interface/ISystemCoin.sol";
import "./interface/IDSOracle.sol";

contract CollateralVault is Initializable, UUPSUpgradeable, PausableUpgradeable, OwnableUpgradeable, ReentrancyGuardUpgradeable {

    using SafeERC20Upgradeable for IERC20Upgradeable;
    using SafeERC20Upgradeable for IBRT;
    using SafeERC20Upgradeable for ISystemCoin;

    // Contract general data 
    uint256 internal BIPS_DIVISOR;                          // Constant 10000(denominator)
    uint256 internal MAX_UINT;                              // Constant uint256 Max number
    uint256 internal poolLength;                            // All BRT pools length
    mapping(uint256 => PoolInfo) public poolInfo;           // Collateral BRT Poolinfo
    mapping(address => uint256) public poolId1;             // poolId1 count from 1, subtraction 1 before using with poolInfo
    mapping(address => bool) public authorized;             // Authorized Admins
    uint256 internal DEV_FEE_BIPS;                          // Borrow Fees
    ISystemCoin internal systemCoin;

    // Interest Engine data
    uint256 internal rayDecimals;                           // 1e27
    uint256 internal interestInterval;                      // 3600s/1hr
    int256 internal interestRate;                           // Interest for loan(1%/yr, value convert to in hrs)
    mapping(uint256 => mapping(address => assetInfo)) public assetInfoMap;  // User Debt balance(stable coin) **Pid=>User's Address=>StableCoinAsset

    // Collateral Vault Engine data
    uint256 public emergencyStart;                          // For emergency exit loan position(after 3 day)
    uint256 internal calDecimals;                           // 1e18
    address public liqPool;
    address public reservePool;
    mapping(uint256 => mapping(address => uint256)) public collateralBalances;    // user BRT token collateral amount

    struct PoolInfo {
        IBRT collateralToken;               // BRT token address
        IDSOracle oracle;                   // oracle to get collateralToken price
        uint256 collateralRate;             // Collateral ratio (E.g:2e18 => 200%, 3e18 => 300%), oracle price is 18 decimals
        uint256 totalAssetAmount;           // Pools total net minted system stable coin
        uint256 latestSettleTime;           // Latest time to settlement
        uint256 accumulatedRate;            // Accumulated interest
        uint256 assetCeiling;               // Maximum amount of debt that can be generated with this collateral type
        uint256 assetFloor;                 // Minimum amount of debt that must be generated by a SAFE using this collateral
        uint256 liquidationPenalty;         // User's penalty rate for position liquidated(E.g: 2e18 => E.g:20%) decimals:1e18
        bool depositEnabled;            
    }

    struct assetInfo{
        uint256 originAsset;            // User's borrow system coin amount
        uint256 assetAndInterest;
        uint256 interestRateOrigin;
    }

    event Join(uint256 indexed pid, address indexed sender, address indexed account, uint256 amount);
    event BorrowSystemCoin(uint256 indexed pid, address indexed sender, address indexed account, uint256 amount);
    event RepaySystemCoin(uint256 indexed pid, address indexed sender, address indexed account, uint256 amount);
    event Exit(uint256 indexed pid, address indexed sender, address indexed account, uint256 amount);
    event EmergencyExit(uint256 indexed pid, address indexed sender, address indexed account, uint256 amount);
    event Liquidate(uint256 indexed pid, address indexed sender, address indexed account, address collateralToken, uint256 debt, uint256 punishment, uint256 amount);

    event SetInterestInfo(address indexed from, int256 _interestRate, uint256 _interestInterval);
    event SetLiquidationInfo(address indexed sender, uint256 liquidationPenalty);
    event SetPoolLimitation(address indexed sender, uint256 assetCeiling, uint256 assetFloor);
    event SetPoolCollateralRate(address indexed sender, uint256 _collateralRate);
    event SetLiqPool(address indexed sender, address newLiqPool);
    event SetReservePool(address indexed sender, address newReservePool);
    event SetBorrowFees(address indexed sender, uint256 _New_DEV_FEE_BIPS);
    event SetEmergency(address indexed sender, uint256 emergencyStart);
    event PoolsEnabled(uint256 indexed pid, bool depositEnabled);

    modifier onlyAuthorized() {
        require(authorized[msg.sender] || owner() == msg.sender);
        _;
    }

    modifier notZeroAddress(address inputAddress) {
        require(inputAddress != address(0) , "collateralVault : input zero address");
        _;
    }

    modifier settleAccount(uint256 pid, address account) {
        _interestSettlement(pid);
        settleUserInterest(pid, account);
        _;
    }

    /// @custom:oz-upgrades-unsafe-allow constructor
    constructor() {
        _disableInitializers();
    }
    
    /***************************
    * @dev INITIAL SETUP START
    ****************************/
    function initContract(address _liqPool, address _reservePool, address _systemCoin, int256 _interestRate, uint256 _feeInterval, uint256 _DEV_FEE_BIPS, bool update) external onlyOwner{
        require(_liqPool != address(0),"A!=0");
        require(_reservePool != address(0),"A!=0");
        require(_systemCoin != address(0),"A!=0");
        require(_DEV_FEE_BIPS <= 10000,"Fee>=100%");
        liqPool = _liqPool;
        reservePool = _reservePool;
        systemCoin = ISystemCoin(_systemCoin);
        DEV_FEE_BIPS = _DEV_FEE_BIPS;
        _setInterestInfo(_interestRate, _feeInterval, 12e26, 8e26, update);
    }

    function add(IBRT _collateralToken, address _oracle, uint256 _collateralRate, uint256 _assetCeiling, uint256 _assetFloor, uint256 _liquidationPenalty) external onlyOwner {
        require(address(_collateralToken) != address(0),"A!=0");
        require(_oracle != address(0),"A!=0");
        require(poolId1[address(_collateralToken)] == 0, "coll.Token is in list");
        require(_collateralRate >= 1e18 && _collateralRate <= 5e18 ,"Collateral rate overflow!");
        require(_liquidationPenalty <= 5e17 && (calDecimals+_liquidationPenalty) <= _collateralRate,"Liquidate overflow!");
        poolId1[address(_collateralToken)] = poolLength + 1;
        poolInfo[poolLength] = PoolInfo({
            collateralToken : _collateralToken,
            oracle : IDSOracle(_oracle),
            collateralRate : _collateralRate,
            totalAssetAmount : 0,
            latestSettleTime : block.timestamp,
            accumulatedRate : rayDecimals,
            assetCeiling : _assetCeiling,
            assetFloor : _assetFloor,
            liquidationPenalty: _liquidationPenalty,
            depositEnabled : true
        });
        poolLength++;
    }

    /*********************************
    * @dev Collateral CORE FUNCTIONS
    **********************************/
    function join(uint256 pid, address account, uint256 amount) whenNotPaused nonReentrant settleAccount(pid, account) external {
        _join(pid, account, amount);
    }

    function joinAndBorrow(uint256 pid, uint256 collateralamount, uint256 systemCoinAmount) whenNotPaused nonReentrant settleAccount(pid, msg.sender) external {
        _join(pid, msg.sender, collateralamount);
        if (systemCoinAmount > 0) {
            _borrowSystemCoin(pid, msg.sender, systemCoinAmount);
        }
    }

    function borrowSystemCoin(uint256 pid, address account, uint256 amount) whenNotPaused nonReentrant settleAccount(pid, msg.sender) external {
        _borrowSystemCoin(pid, account, amount);
    }

    function exit(uint256 pid, address account, uint256 amount) whenNotPaused nonReentrant settleAccount(pid, msg.sender) external {
        require(checkLiquidate(pid, msg.sender, amount, 0) , "collateral overflow!");
        PoolInfo storage pool = poolInfo[pid];
        collateralBalances[pid][msg.sender] = collateralBalances[pid][msg.sender] - (amount);
        pool.collateralToken.safeTransfer(account, amount);
        emit Exit(pid, msg.sender, account, amount);
    }

    function emergencyExit(uint256 pid, address account) whenPaused nonReentrant notZeroAddress(account) external {
        require(emergencyStart < block.timestamp, "Not at emergency state");
        PoolInfo storage pool = poolInfo[pid];
        uint256 amount = collateralBalances[pid][msg.sender];
        collateralBalances[pid][msg.sender] = 0;
        pool.collateralToken.safeTransfer(account, amount);
        
        emit EmergencyExit(pid, msg.sender, account, amount);
    }

    function repaySystemCoin(uint256 pid, address account, uint256 amount) whenNotPaused nonReentrant settleAccount(pid, account) external {
        if(amount == MAX_UINT) {
            amount = assetInfoMap[pid][account].assetAndInterest;
        }
        _repaySystemCoin(pid, account, amount);
    }

    function liquidate(uint256 pid, address account) whenNotPaused nonReentrant settleAccount(pid, account) external onlyAuthorized {
        require(account != address(0),"A!=0");
        require(!checkLiquidate(pid, account, 0, 0) , "liq check error!");
        _liquidate(pid, account);
    }

    /*******************************
    * @dev CORE Internal FUNCTIONS
    ********************************/
    function _join(uint256 pid, address account, uint256 amount) internal {
        PoolInfo storage pool = poolInfo[pid];
        (uint256 userCompoundReceipt, , , , , , ) = pool.collateralToken.userInfo(account);
        require(pool.depositEnabled == true, "Dep N/A");
        require(userCompoundReceipt >= (amount+collateralBalances[pid][account]));
        pool.collateralToken.safeTransferFrom(msg.sender, address(this), amount);
        collateralBalances[pid][account] = collateralBalances[pid][account] + (amount);
        emit Join(pid, msg.sender, account, amount);
    }

    function _borrowSystemCoin(uint256 pid, address account, uint256 amount) internal {
        require(checkLiquidate(pid, msg.sender, 0, amount) , "overflow liq limit!");
        uint256 borrowFees = amount * DEV_FEE_BIPS / BIPS_DIVISOR;
        systemCoin.mint(account, amount-borrowFees);
        systemCoin.mint(reservePool, borrowFees);
        addAsset(pid, msg.sender, amount);
        emit BorrowSystemCoin(pid, msg.sender, account, amount);
    }

    function _repaySystemCoin(uint256 pid, address account, uint256 amount) internal {
        uint256 _repayDebt = subAsset(pid, account, amount);
        if(amount>_repayDebt){
            systemCoin.safeTransferFrom(msg.sender, liqPool, amount - _repayDebt);       // Interest of loan
            systemCoin.burn(msg.sender, _repayDebt);
        } else {
            systemCoin.burn(msg.sender, amount);
        }
        emit RepaySystemCoin(pid, msg.sender, account, amount);
    }

    function _liquidate(uint256 pid, address account) internal {
        PoolInfo storage pool = poolInfo[pid];

        (,uint256 collateralPrice) = oraclePrice(pid, address(pool.collateralToken));        // colateralPrice in 1e18
        uint256 collateral = collateralBalances[pid][account];
        uint256 allDebt = assetInfoMap[pid][account].assetAndInterest;
        uint256 penalty = allDebt * pool.liquidationPenalty / calDecimals;
        subAsset(pid, account, allDebt);

        allDebt += penalty;
        uint256 _payback = allDebt * calDecimals / collateralPrice;     // liquidate token amount
        _payback = _payback <= collateral ? _payback : collateral;
        collateralBalances[pid][account] = collateral - _payback;

        pool.collateralToken.liquidateCollateral(account, _payback);
        emit Liquidate(pid, msg.sender, account, address(pool.collateralToken), allDebt, penalty, _payback);  
    }

    /******************************
    * @dev Vault Engine FUNCTIONS 
    *******************************/
    function setInterestRate(int256 _interestRate, uint256 feeInterval, bool update) external onlyOwner{
        _setInterestInfo(_interestRate, feeInterval, 12e26, 8e26, update);
    }

    function canLiquidate(uint256 pid, address account) external view returns (bool) {
        PoolInfo storage pool = poolInfo[pid];
        uint256 assetAndInterest = getAssetBalance(pid, account);
        (, uint256 collateralPrice) = oraclePrice(pid, address(pool.collateralToken));
        uint256 allCollateral = collateralBalances[pid][account] * (collateralPrice);
        return assetAndInterest * (pool.collateralRate) > allCollateral;
    }

    function checkLiquidate(uint256 pid, address account, uint256 removeCollateral, uint256 newMint) internal view returns(bool) {
        PoolInfo storage pool = poolInfo[pid];
        (bool inTol, uint256 collateralPrice) = oraclePrice(pid, address(pool.collateralToken));
        require(inTol, "Oracle price is abnormal!");
        uint256 allCollateral = (collateralBalances[pid][account] - removeCollateral) * (collateralPrice);
        uint256 assetAndInterest = assetInfoMap[pid][account].assetAndInterest + (newMint);
        return assetAndInterest * (pool.collateralRate) <= allCollateral;
    }

    function _setLiquidationInfo(uint256 pid, uint256 _liquidationPenalty) internal {
        PoolInfo storage pool = poolInfo[pid];
        require(_liquidationPenalty <= 5e17 && (calDecimals+_liquidationPenalty) <= pool.collateralRate,"Liquidate overflow!");
        pool.liquidationPenalty = _liquidationPenalty;
        emit SetLiquidationInfo(msg.sender, _liquidationPenalty);
    }

    /*********************************
    * @dev Interest Engine FUNCTIONS 
    **********************************/
    function _setInterestInfo(int256 _interestRate, uint256 _interestInterval, uint256 maxRate, uint256 minRate, bool _withUpdate) internal {
        require(_interestRate<=1e27 && _interestRate>=-1e27, "interest rate too large");
        require(_interestInterval>0, "Interval > zero");
        uint256 newLimit = rpower(uint256(1e27+_interestRate) , 31536000/_interestInterval, rayDecimals);
        require(newLimit<=maxRate && newLimit>=minRate, "interest rate is out of range");
        if (_withUpdate) {
            massInterestSettlement();
        }
        interestRate = _interestRate;
        interestInterval = _interestInterval;
        emit SetInterestInfo(msg.sender, _interestRate, _interestInterval);
    }

    function massInterestSettlement() public {
        for (uint256 pid = 0; pid < poolLength; ++pid) {
            _interestSettlement(pid);
        }
    }

    function interestSettlement(uint256 pid) external {
        _interestSettlement(pid);
    }

    function _interestSettlement(uint256 pid) internal {
        PoolInfo storage pool = poolInfo[pid];
        uint256 _interestInterval = interestInterval;
        if (_interestInterval>0) {
            uint256 newRate = newAccumulatedRate(pid);
            pool.totalAssetAmount = pool.totalAssetAmount * newRate /pool.accumulatedRate;
            pool.accumulatedRate = newRate;
            pool.latestSettleTime = block.timestamp/_interestInterval*_interestInterval;
        } else {
            pool.latestSettleTime = block.timestamp;
        }
    }

    function newAccumulatedRate(uint256 pid) internal virtual view returns (uint256) {
        PoolInfo storage pool = poolInfo[pid];
        uint256 newRate = rpower(uint256(1e27+interestRate) , (block.timestamp - pool.latestSettleTime) /interestInterval, rayDecimals);            
        return pool.accumulatedRate * (newRate) /rayDecimals;           
    }

    function getAssetBalance(uint256 pid, address account) public virtual view returns(uint256) {
        if(assetInfoMap[pid][account].interestRateOrigin == 0 || interestInterval == 0) {
            return 0;
        }
        uint256 newRate = newAccumulatedRate(pid);
        return assetInfoMap[pid][account].assetAndInterest * (newRate) / assetInfoMap[pid][account].interestRateOrigin;
    }

    function addAsset(uint256 pid, address account, uint256 amount) internal {
        PoolInfo storage pool = poolInfo[pid];
        assetInfoMap[pid][account].originAsset += amount;
        assetInfoMap[pid][account].assetAndInterest += amount;
        pool.totalAssetAmount += amount;
        require(assetInfoMap[pid][account].assetAndInterest >= pool.assetFloor, "Debt < limit");
        require(pool.totalAssetAmount <= pool.assetCeiling, "vault debt overflow");
    }
    /**
     * @dev repay user's debt and taxes.
     * @param amount repay amount.
     */
    function subAsset(uint256 pid, address account, uint256 amount) internal returns(uint256) {
        PoolInfo storage pool = poolInfo[pid];
        uint256 originBalance = assetInfoMap[pid][account].originAsset;
        uint256 assetAndInterest = assetInfoMap[pid][account].assetAndInterest;
        
        uint256 _repayDebt;
        if(assetAndInterest == amount) {
            _repayDebt = originBalance;
            assetInfoMap[pid][account].originAsset = 0;
            assetInfoMap[pid][account].assetAndInterest = 0;
        } else if(assetAndInterest > amount) {
            _repayDebt = originBalance * (amount) /assetAndInterest;
            assetInfoMap[pid][account].assetAndInterest = assetAndInterest - (amount);
            require(assetInfoMap[pid][account].assetAndInterest >= pool.assetFloor, "Debt < the limit");
            assetInfoMap[pid][account].originAsset = originBalance - (_repayDebt);
        } else {
            require(false, "overflow asset balance");
        }
        pool.totalAssetAmount = pool.totalAssetAmount - (amount);
        return _repayDebt;
    }

    function rpower(uint256 x, uint256 n, uint256 base) internal pure returns (uint256 z) {
        assembly {
            switch x case 0 {switch n case 0 {z := base} default {z := 0}}      // if interestRate is +ve, conditions are not going to happen
            default {
                switch mod(n, 2) case 0 { z := base } default { z := x }        // when n=0 z=base, when n=1 z=x(Compound once), when n=2 z=(x with additonal power calculation)
                let half := div(base, 2)  // for rounding.
                // for { n := div(n, 2) } n { n := div(n, 2) } {                // SourceCode
                for { n := div(n, 2) } lt(0,n) { n := div(n,2) } {              // for(n=n/2;n>0;n/=2)
                    let xx := mul(x, x) 
                    if iszero(eq(div(xx, x) , x)) { revert(0, 0) }
                    let xxRound := add(xx, half) 
                    if lt(xxRound, xx) { revert(0, 0) }
                    x := div(xxRound, base) 
                    if mod(n, 2) {
                        let zx := mul(z, x) 
                        if and(iszero(iszero(x)) , iszero(eq(div(zx, x) , z)) ) { revert(0, 0) }
                        let zxRound := add(zx, half) 
                        if lt(zxRound, zx) { revert(0, 0) }
                        z := div(zxRound, base) 
                    }
                }
            }
        }
    }

    function settleUserInterest(uint256 pid, address account) internal {
        PoolInfo storage pool = poolInfo[pid];
        assetInfoMap[pid][account].assetAndInterest = _settlement(pid, account);
        assetInfoMap[pid][account].interestRateOrigin = pool.accumulatedRate;
    }
    /**
     * @dev subfunction, settle user's latest tax amount.
     * @param account user's account
     */
    function _settlement(uint256 pid, address account) internal virtual view returns (uint256) {
        PoolInfo storage pool = poolInfo[pid];
        if (assetInfoMap[pid][account].interestRateOrigin == 0) {
            return 0;
        }
        return assetInfoMap[pid][account].assetAndInterest * (pool.accumulatedRate) / assetInfoMap[pid][account].interestRateOrigin;
    }

    /*******************************
    * @dev Oracle Engine FUNCTIONS
    ********************************/
    function oraclePrice(uint256 pid, address asset) internal view returns (bool,uint256) {
        PoolInfo memory pool = poolInfo[pid];
        (bool inTol,uint256 price) = pool.oracle.getBRTPrice(asset);
        require(price >= 100 && price <= 1e45,"oracle price error");
        return (inTol,price);
    }

    function oracleLpPrice(uint256 pid, address asset) external view returns (bool,uint256) {
        PoolInfo memory pool = poolInfo[pid];
        (bool inTol,uint256 price) = pool.oracle.getPriceInfo(asset);
        return (inTol,price);
    }

    function setOracleAddress(uint256 pid, address _oracle) external onlyOwner {
        require(_oracle != address(0),"A!=0");
        PoolInfo storage pool = poolInfo[pid];
        pool.oracle = IDSOracle(_oracle);
    }

    /*****************************************
    * @dev View FUNCTIONS for external usage
    ******************************************/
    function getPoolLength() external view returns (uint256) {
        return poolLength;
    }

    function getOracleAddress(uint256 pid) external view returns(address) {
        PoolInfo memory pool = poolInfo[pid];
        return address(pool.oracle);
    }

    function getInterestInfo() external view returns(int256,uint256) {
        return (interestRate, interestInterval);
    }

    function getSystemCoin() external view returns(address) {
        return address(systemCoin);
    }

    function getMaxBorrowAmount(uint256 pid, address account, uint256 newAddCollateral) external view returns(uint256) {
        PoolInfo storage pool = poolInfo[pid];
        uint256 allDebt = getAssetBalance(pid, account);
        (, uint256 collateralPrice) = oraclePrice(pid, address(pool.collateralToken));
        uint256 newBorrow = (collateralBalances[pid][account] + newAddCollateral) * collateralPrice / pool.collateralRate;
        if (newBorrow > allDebt) {
            return newBorrow - allDebt;
        }
        return 0;
    }
    
    /****************************
    * @dev ONLY OWNER FUNCTIONS
    *****************************/
    // Rescue any token function, just in case if any user not able to withdraw token from the smart contract.
    function rescueDeployedFunds(address token, uint256 amount, address to) external onlyOwner {
        require(to != address(0) , "0A");
        IERC20Upgradeable(token).safeTransfer(to, amount);
    }

    function setPoolLimitation(uint256 pid, uint256 newAssetCeiling,uint256 newAssetFloor) external onlyOwner {
        PoolInfo storage pool = poolInfo[pid];
        pool.assetCeiling = newAssetCeiling;
        pool.assetFloor = newAssetFloor;
        emit SetPoolLimitation(msg.sender, newAssetCeiling, newAssetFloor);
    }

    function setPoolCollateralRate(uint256 pid, uint256 _collateralRate) external onlyOwner {
        require(_collateralRate >= 1e18 && _collateralRate <= 5e18 , "Collateral Vault : collateral rate overflow!");
        PoolInfo storage pool = poolInfo[pid];
        pool.collateralRate = _collateralRate;
        emit SetPoolCollateralRate(msg.sender, _collateralRate);
    }

    function setLiquidationInfo(uint256 pid, uint256 newLiquidationPenalty) external onlyOwner {
        _setLiquidationInfo(pid ,newLiquidationPenalty);
    }

    function setLiqPool(address newLiqPool)external onlyOwner {
        require(newLiqPool != address(0),"A!0");
        liqPool = newLiqPool;
        emit SetLiqPool(msg.sender, newLiqPool);
    }

    function setReservePool(address newReservePool) external onlyOwner {
        require(newReservePool != address(0),"A!0");
        reservePool = newReservePool;
        emit SetReservePool(msg.sender, newReservePool);
    }

    function setBorrowFees(uint256 new_DEV_FEE_BIPS) external onlyOwner {
        require(new_DEV_FEE_BIPS > 0 && new_DEV_FEE_BIPS <= 10000,"Out of Range");
        DEV_FEE_BIPS = new_DEV_FEE_BIPS;
        emit SetBorrowFees(msg.sender, new_DEV_FEE_BIPS);
    }

    function addAuthorized(address _toAdd) onlyOwner external {
        authorized[_toAdd] = true;
    }

    function removeAuthorized(address _toRemove) onlyOwner external {
        require(_toRemove != msg.sender,"remove owner");
        authorized[_toRemove] = false;
    }

    function setEmergency() external whenPaused onlyOwner {
        emergencyStart = block.timestamp + 1 days;
        emit SetEmergency(msg.sender,emergencyStart);
    }
    /**
     * @notice Enable/disable long&short token
    */
    function updatePoolsEnabled(uint256 pid, bool depositEnabled) external onlyOwner {
        PoolInfo storage pool = poolInfo[pid];
        pool.depositEnabled = depositEnabled;
        
        emit PoolsEnabled(pid, depositEnabled);
    }

    function _authorizeUpgrade(address) internal override onlyOwner {}

    /***************************************************************
     * @dev Initialize smart contract functions - only called once
     ***************************************************************/
    function initialize() external initializer {
        MAX_UINT = type(uint256).max;
        emergencyStart = MAX_UINT;      // Initial setting: Max means not started
        BIPS_DIVISOR = 10000;
        rayDecimals = 1e27; 
        calDecimals = 1e18;

        __ReentrancyGuard_init_unchained();
        __Pausable_init();
        __Ownable_init();
        __UUPSUpgradeable_init();
    }
}